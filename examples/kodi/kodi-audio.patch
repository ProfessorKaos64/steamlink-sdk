From 7fee883f8574aeaa1babaf251d6a82f9e8f05334 Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Mon, 15 Feb 2016 17:19:07 -0800
Subject: [PATCH] Steam Link: Add hardware audio support

---
 configure.ac                                     |  10 ++
 xbmc/cores/AudioEngine/AESinkFactory.cpp         |  25 +++
 xbmc/cores/AudioEngine/Makefile.in               |   3 +
 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp | 208 +++++++++++++++++++++++
 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h   |  64 +++++++
 5 files changed, 310 insertions(+)
 create mode 100644 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp
 create mode 100644 xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h

diff --git a/configure.ac b/configure.ac
index 13e5bac..39767bf 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1302,6 +1302,16 @@ else
   AC_MSG_RESULT($alsa_disabled)
 fi
 
+# Steam Link
+AC_CHECK_HEADERS([SLVideo.h SLAudio.h], steamlink_found=yes,)
+if test "$steamlink_found" = "yes"; then
+  USE_STEAMLINK=1
+  use_pulse=no
+  AC_DEFINE([HAS_STEAMLINK], [], [Define if we are compiling with the Steam Link SDK])
+  LIBS="$LIBS -lSLVideo -lSLAudio"
+fi
+AC_SUBST(USE_STEAMLINK)
+
 # PulseAudio
 if test "x$use_pulse" != "xno"; then
   if test "$host_vendor" = "apple" ; then
diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index 603a944..dcb7659 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -39,6 +39,9 @@
   #if defined(HAS_PULSEAUDIO)
     #include "Sinks/AESinkPULSE.h"
   #endif
+  #if defined(HAS_STEAMLINK)
+    #include "Sinks/AESinkSteamLink.h"
+  #endif
   #include "Sinks/AESinkOSS.h"
 #else
   #pragma message("NOTICE: No audio sink for target platform.  Audio output will not be available.")
@@ -78,6 +81,9 @@ void CAESinkFactory::ParseDevice(std::string &device, std::string &driver)
   #if defined(HAS_PULSEAUDIO)
         driver == "PULSE"       ||
   #endif
+  #if defined(HAS_STEAMLINK)
+        driver == "STEAMLINK"   ||
+  #endif
         driver == "OSS"         ||
 #endif
         driver == "PROFILER"    ||
@@ -125,6 +131,10 @@ IAESink *CAESinkFactory::TrySink(std::string &driver, std::string &device, AEAud
     if (driver == "ALSA")
       sink = new CAESinkALSA();
  #endif
+  #if defined(HAS_STEAMLINK)
+    if (driver == "STEAMLINK")
+      sink = new STEAMLINK::CAESinkSteamLink();
+  #endif
     if (driver == "OSS")
       sink = new CAESinkOSS();
 #endif
@@ -240,6 +250,10 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
     if (envSink == "ALSA")
       CAESinkALSA::EnumerateDevicesEx(info.m_deviceInfoList, force);
     #endif
+    #if defined(HAS_STEAMLINK)
+    if (envSink == "STEAMLINK")
+      STEAMLINK::CAESinkSteamLink::EnumerateDevicesEx(info.m_deviceInfoList);
+    #endif
     if (envSink == "OSS")
       CAESinkOSS::EnumerateDevicesEx(info.m_deviceInfoList, force);
 
@@ -275,6 +289,17 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
   }
   #endif
 
+  #if defined(HAS_STEAMLINK)
+  info.m_deviceInfoList.clear();
+  info.m_sinkName = "STEAMLINK";
+  STEAMLINK::CAESinkSteamLink::EnumerateDevicesEx(info.m_deviceInfoList);
+  if(!info.m_deviceInfoList.empty())
+  {
+    list.push_back(info);
+    return;
+  }
+  #endif
+
   info.m_deviceInfoList.clear();
   info.m_sinkName = "OSS";
   CAESinkOSS::EnumerateDevicesEx(info.m_deviceInfoList, force);
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 7aab111..e2611c6 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -55,6 +55,9 @@ SRCS += Sinks/AESinkOSS.cpp
 ifeq (@USE_PULSE@,1)
 SRCS += Sinks/AESinkPULSE.cpp
 endif
+ifeq (@USE_STEAMLINK@,1)
+SRCS += Sinks/AESinkSteamLink.cpp
+endif
 endif
 
 SRCS += DSPAddons/ActiveAEDSP.cpp
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp
new file mode 100644
index 0000000..a696869
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.cpp
@@ -0,0 +1,207 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "AESinkSteamLink.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "utils/log.h"
+#include "utils/TimeUtils.h"
+
+// Steam Link audio API
+#include "SLAudio.h"
+
+#include <cstring>
+#include <unistd.h>
+
+#define SL_SAMPLE_RATE  48000
+#define SINK_FEED_MS    50 // Steam Link game streaming uses 10ms
+#define CACHE_TOTAL_MS  200
+
+using namespace STEAMLINK;
+
+namespace
+{
+  void LogFunction(void *pContext, ESLAudioLog eLogLevel, const char *pszMessage)
+  {
+    switch (eLogLevel)
+    {
+    case k_ESLAudioLogDebug:
+      CLog::Log(LOGDEBUG, "%s", pszMessage);
+      break;
+    case k_ESLAudioLogInfo:
+      CLog::Log(LOGINFO, "%s", pszMessage);
+      break;
+    case k_ESLAudioLogWarning:
+      CLog::Log(LOGWARNING, "%s", pszMessage);
+      break;
+    case k_ESLAudioLogError:
+      CLog::Log(LOGERROR, "%s", pszMessage);
+      break;
+    default:
+      break;
+    }
+  }
+}
+
+CAESinkSteamLink::CAESinkSteamLink() :
+  m_lastPackageStamp(0.0),
+  m_delaySec(0.0),
+  m_context(nullptr),
+  m_stream(nullptr)
+{
+  SLAudio_SetLogLevel(k_ESLAudioLogDebug);
+  SLAudio_SetLogFunction(LogFunction, nullptr);
+}
+
+CAESinkSteamLink::~CAESinkSteamLink()
+{
+  Deinitialize();
+  SLAudio_SetLogFunction(nullptr, nullptr);
+}
+
+bool CAESinkSteamLink::Initialize(AEAudioFormat &format, std::string &device)
+{
+  Deinitialize();
+
+  format.m_dataFormat    = AE_FMT_S16NE;
+  format.m_sampleRate    = SL_SAMPLE_RATE;
+  format.m_frames        = format.m_sampleRate * SINK_FEED_MS / 1000;
+  format.m_frameSize     = format.m_channelLayout.Count() * (CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3);
+  m_format = format;
+
+  CSLAudioContext* context = SLAudio_CreateContext();
+  if (context)
+  {
+    CSLAudioStream* stream = SLAudio_CreateStream(context, m_format.m_sampleRate, m_format.m_channelLayout.Count(), format.m_frames * format.m_frameSize);
+    if (stream)
+    {
+      // Success
+      m_context = context;
+      m_stream = stream;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "SteamLinkAudio: Failed to create stream");
+      SLAudio_FreeContext(context);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "SteamLinkAudio: Failed to create context");
+  }
+
+  return m_context != nullptr;
+}
+
+void CAESinkSteamLink::Deinitialize()
+{
+  if (m_stream)
+  {
+    SLAudio_FreeStream(static_cast<CSLAudioStream*>(m_stream));
+    m_stream = nullptr;
+  }
+  if (m_context)
+  {
+    SLAudio_FreeContext(static_cast<CSLAudioContext*>(m_context));
+    m_context = nullptr;
+  }
+}
+
+double CAESinkSteamLink::GetCacheTotal()
+{
+  return CACHE_TOTAL_MS / 1000.0;
+}
+
+unsigned int CAESinkSteamLink::AddPackets(uint8_t **data, unsigned int frames, unsigned int offset)
+{
+  const double packetTimeSecs = 1.0 * (frames - offset) / m_format.m_sampleRate;
+
+  // Update delay for elapsed time
+  const double nowSecs = (double)CurrentHostCounter() / CurrentHostFrequency();
+  if (m_lastPackageStamp > 0.0)
+  {
+    const double elapsedSecs = nowSecs - m_lastPackageStamp;
+    m_delaySec -= elapsedSecs;
+    if (m_delaySec < 0.0)
+      m_delaySec = 0.0;
+  }
+  m_lastPackageStamp = nowSecs;
+
+  // Ensure space in the buffer
+  const double availableSecs = GetCacheTotal() - GetDelaySecs();
+
+  const int sleepTimeUs = (int)((SINK_FEED_MS / 1000.0 - availableSecs) * 1000 * 1000);
+
+  if (sleepTimeUs > 0)
+    usleep(sleepTimeUs);
+
+  // Add the audio data
+  void* buffer = SLAudio_BeginFrame(static_cast<CSLAudioStream*>(m_stream));
+  std::memcpy(buffer, data[0] + offset * m_format.m_frameSize, (frames - offset) * m_format.m_frameSize);
+  SLAudio_SubmitFrame(static_cast<CSLAudioStream*>(m_stream));
+
+  // Increase the delay for the added packet
+  m_delaySec += packetTimeSecs;
+
+  return frames - offset;
+}
+
+void CAESinkSteamLink::GetDelay(AEDelayStatus &status)
+{
+  status.SetDelay(GetDelaySecs());
+}
+
+void CAESinkSteamLink::Drain()
+{
+  unsigned int usecs = (unsigned int)(GetDelaySecs() * 1000 * 1000);
+  if (usecs > 0)
+    usleep(usecs);
+
+  m_lastPackageStamp = 0.0;
+  m_delaySec = 0.0;
+}
+
+double CAESinkSteamLink::GetDelaySecs()
+{
+  return m_delaySec;
+}
+
+double CAESinkSteamLink::GetSLDelaySecs()
+{
+  // Expensive, but every 10ms-50ms is OK
+  uint32_t frames = SLAudio_GetQueuedAudioSamples(static_cast<CSLAudioStream*>(m_stream));
+
+  return (double)frames / m_format.m_sampleRate;
+}
+
+void CAESinkSteamLink::EnumerateDevicesEx(AEDeviceInfoList &deviceInfoList)
+{
+  CAEDeviceInfo info;
+
+  info.m_deviceType = AE_DEVTYPE_PCM;
+  info.m_deviceName = "SteamLink";
+  info.m_displayName = "Steam Link Low Latency Audio";
+  info.m_displayNameExtra = "";
+  info.m_channels += AE_CH_FL;
+  info.m_channels += AE_CH_FR;
+  info.m_sampleRates.push_back(SL_SAMPLE_RATE);
+  info.m_dataFormats.push_back(AE_FMT_S16NE);
+
+  deviceInfoList.push_back(info);
+}
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h
new file mode 100644
index 0000000..972559c
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkSteamLink.h
@@ -0,0 +1,64 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      Copyright (C) 2016 Valve Corporation
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "cores/AudioEngine/Interfaces/AESink.h"
+#include "cores/AudioEngine/Utils/AEDeviceInfo.h"
+
+#include <stdint.h>
+
+#define STEAM_LINK_SINK_NAME  "SteamLinkAudio"
+
+namespace STEAMLINK
+{
+
+class CAESinkSteamLink : public IAESink
+{
+public:
+  virtual const char* GetName() override { return STEAM_LINK_SINK_NAME; }
+
+  CAESinkSteamLink();
+  virtual ~CAESinkSteamLink();
+
+  // implementation of IAESink
+  virtual bool Initialize(AEAudioFormat &format, std::string &device) override;
+  virtual void Deinitialize() override;
+  virtual double GetCacheTotal() override;
+  virtual unsigned int AddPackets(uint8_t **data, unsigned int frames, unsigned int offset) override;
+  virtual void GetDelay(AEDelayStatus &status) override;
+  virtual void Drain() override;
+
+  static void EnumerateDevicesEx(AEDeviceInfoList &deviceInfoList);
+
+private:
+  double GetDelaySecs();
+  double GetSLDelaySecs(); // Get steam link delay in seconds
+
+  // AE stuff
+  AEAudioFormat m_format;
+  double        m_lastPackageStamp;
+  double        m_delaySec; // Estimated delay in seconds
+
+  // Steam Link stuff
+  void* m_context;
+  void* m_stream;
+};
+
+}
-- 
2.5.0

